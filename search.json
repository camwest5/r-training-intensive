[
  {
    "objectID": "Projects/project_gallery.html",
    "href": "Projects/project_gallery.html",
    "title": "Project Gallery",
    "section": "",
    "text": "Goalkeepers and their heights\n\n\n\n\n\n\nCameron West and Stéphane Guillou\n\n\nJan 2, 2025\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Workshops",
      "The Project",
      "Project Gallery"
    ]
  },
  {
    "objectID": "Projects/details.html",
    "href": "Projects/details.html",
    "title": "Overview",
    "section": "",
    "text": "The best way to learn is by doing. That’s why, over the these three days, you are tasked with analysing, visualising and reporting on a set of data!\nRoughly 50% of our intensive is dedicated to working on the project. Working in groups of 2-4, you’ll need to use the techniques we learn to draw some observations about your chosen dataset.\nThe end goal will be a quick fire (low stakes) one-minute presentation with a dashboard to complement.",
    "crumbs": [
      "Workshops",
      "The Project",
      "Overview"
    ]
  },
  {
    "objectID": "Projects/details.html#the-datasets",
    "href": "Projects/details.html#the-datasets",
    "title": "Overview",
    "section": "The datasets",
    "text": "The datasets\nWe have eight datasets for you to choose from:\n\n\n\nDataset\nDescription\n\n\n\n\nWorld populations\nA summary of world populations and corresponding statistics\n\n\nSoccer players\nA summary of about 250 2024 soccer players\n\n\nCoffee survey\nA survey of coffee preferences\n\n\nMelbourne housing data\nA collection of houses for sale in Melbourne\n\n\nGoodreads books\nData for 50,000 goodreads books\n\n\nQueensland hospitals\nEmergency department statistics\n\n\nQueensland fuel prices\nFuel prices by the pump in Queensland\n\n\nAeroplane bird strikes\nAeroplane bird strike incidents fron the 90s",
    "crumbs": [
      "Workshops",
      "The Project",
      "Overview"
    ]
  },
  {
    "objectID": "Projects/details.html#project-outline",
    "href": "Projects/details.html#project-outline",
    "title": "Overview",
    "section": "Project outline",
    "text": "Project outline\nThere are a few key requirements for the project, but otherwise it’s up to you!\n\nAnalyse a dataset and create some visualisations\nPut together a final dashboard-style report. Anything from a powerpoint slide to an interactive dashboard will do!\nDeliver a quick fire one-minute presentation with your group\n\nWe’ll have 5 sessions during the intensive days to work on the project, just shy of six hours. The goal of these sessions is twofold\n\nTo work on the project, analysing data and creating visualisations\nTo dive deeper into the content, perfect for questions and conversations\n\nWhile you’ll be working in groups, everyone should practise analysing and visualising the data. We recommend distributing roles amongst the group, maybe looking at different variables or different presentation formats.\nYou’re welcome to use the project time however you’d like. Below is a rough guide if you’re unsure:\n\n\n\n\n\n\n\nSession\nRecommendation\n\n\n\n\nTuesday afternoon\nPick a dataset and play with the data\n\n\nWednesday morning\nMore exploratory analysis, consider dividing roles amongst group\n\n\nWednesday afternoon\nStart collecting initial visualisations and preparing format (e.g. dashboard)\n\n\nThursday morning\nContinue analysing and creating visualisations\n\n\nThursday afternoon\nPolish up results\n\n\n\nThe presentations will be during Thursday’s final session at 2:50pm.\nGood luck!",
    "crumbs": [
      "Workshops",
      "The Project",
      "Overview"
    ]
  },
  {
    "objectID": "Workshops/6 - Programming.html",
    "href": "Workshops/6 - Programming.html",
    "title": "Programming Essentials",
    "section": "",
    "text": "In this workshop we cover the building blocks for developing more complex code, looking at",
    "crumbs": [
      "Workshops",
      "Programming Essentials"
    ]
  },
  {
    "objectID": "Workshops/6 - Programming.html#directing-traffic-with-conditionals",
    "href": "Workshops/6 - Programming.html#directing-traffic-with-conditionals",
    "title": "Programming Essentials",
    "section": "Directing traffic with conditionals",
    "text": "Directing traffic with conditionals\nIn the first half of this session we’ll look at two types of control flows: conditionals and loops.\nConditionals allow you to put “gates” in your code, only running sections if a certain condition is true. They are common to most programming languages.\nIn Python, they are called if statements, because you use the if command. For example,\nif (5 &gt; 0) {\n  print(\"We're inside the if statement\")\n}\nThe line print(\"We're inside the if statement\") will only run if 5 &gt; 0 is true. If not, it’ll get skipped.\nCurly brackets are essential. Only code inside them will be governed by conditional\nif (5 &gt; 0) {\n  print(\"We're inside the if statement\")\n}\n\nprint(\"This code always runs\")\nWatch what happens if we change the condition\nif (5 &gt; 10) {\n  print(\"We're inside the if statement\")\n}\n\nprint(\"This code always runs\")\nNow, the first line doesn’t run. That’s the essence of a conditional.\nThere’s not much point to using a condition that will always be true. Typically, you’d use a variable in the condition, for example.\npet_age &lt;- 10\n\nif (pet_age &gt; 10) {\n  print(\"My pet is older than 10\")\n}\n\nLogical operators\nHere is a table of the different operators you can make conditions with. When you run them, they always return either True or False.\n\n\n\n\n\n\n\n\nOperator\nTrue example\nDescription\n\n\n\n\n==\n10 == 10\nSame value and type\n\n\n!=\n\"10\" != 10\nDifferent value or type\n\n\n&gt;\n10 &gt; 5\nGreater than\n\n\n&gt;=\n10 &gt;= 10\nGreater than or equal to\n\n\n&lt;\n5 &lt; 10\nLess than\n\n\n&lt;=\n5 &lt;= 10\nLess than or equal to\n\n\n&&\n10 == 10 && \"apple\" == \"apple\"\nOnly true if both conditions are true.\n\n\n\\|\\|\n10 == 10 \\|\\| \"a\" == \"b\"\nAlways true if one condition is true.\n\n\n\n\n\nelif and else\nif statements only run if the condition is True. What happens if its False? That’s what the else command is for, it’s like a net that catches anything that slipped past if:\npet_age &lt;- 5\n\nif (pet_age &gt; 10) {\n  print(\"My pet is older than 10\")\n} else {\n  print(\"My pet is 10 or younger\")\n}\n\nelse also needs curly brackets!\n\nCheck what happens when you change the age from 5 to 15.\nFinally, what if you wanted to check another condition only if the first one fails? That’s what else if is for. It’s another if statement but it only runs if the first fails.\npet_age = 5\n\nif (pet_age &gt; 10) {\n  print(\"My pet is older than 10\")\n} else if (pet_age &lt; 5) {\n  print(\"My pet is younger than 5\")\n} else {\n  print(\"My pet is 10 or younger\")\n}\nYou can include as many as you’d like\npet_age = 5\n\nif (pet_age &gt; 10) {\n  print(\"My pet is older than 10\")\n} else if (pet_age &lt; 5) {\n  print(\"My pet is younger than 5\")\n} else if (pet_age &lt; 1) {\n  print(\"My pet is freshly born\")\n} else {\n  print(\"My pet is 10 or younger\")\n}",
    "crumbs": [
      "Workshops",
      "Programming Essentials"
    ]
  },
  {
    "objectID": "Workshops/6 - Programming.html#repeat-after-me",
    "href": "Workshops/6 - Programming.html#repeat-after-me",
    "title": "Programming Essentials",
    "section": "Repeat after me",
    "text": "Repeat after me\nSometimes you need to repeat a task multiple times. Sometimes hundreds. Maybe you need to loop through 1 million pieces of data. Not fun.\nR’s loops offer us a way to run a section of code multiple times. There are two types: for loops, which run the code once for each element in a sequence (like a list or string), and while loops, which run until some condition is false.\n\nwhile loops\nThese are almost the same as if statements, except for the fact that they run the code multiple times. Let’s begin with a basic conditional\nnumber &lt;- 5\n\nif (number &lt; 5) {\n  paste(number, \"is less than 10.\")\n}\n\nThe paste function lets you print multiple things together\n\nWhat if we wanted to check all the numbers between 5 and 10? We can use a while loop.\nnumber &lt;- 5\n\nwhile (number &lt; 5) {\n  print(paste(number, \"is less than 10.\"))\n  number &lt;- number + 1\n}\n\nWe need to include paste inside print because we’re doing it multiple times.\n\nWe’ve done two things\n\nReplace if with while\nIntroduce number = number + 1 to increase the number each time.\n\n\nWithout step 2, we’d have an infinite loop – one that never stops, because the condition would always be true!\n\nWhile loops are useful for repeating code an indeterminate number of times.\n\n\nfor loops\nRealistically, you’re most likely to use a for loop. They’re inherently safer (you can’t have an infinite loop) and often handier.\nIn R, for loops iterate through a sequence, like the objects in a list. This is more like other languages’ foreach, than most’s for.\nLet’s say you have a vector of different fruit\nlist_of_fruits &lt;- c(\"apple\", \"banana\", \"cherry\")\nand you want to run a section of code on \"apple\", then \"banana\", then \"cherry\". Maybe you want to know which ones have the letter “a”. We can start with a for loop\nlist_of_fruits &lt;- c(\"apple\", \"banana\", \"cherry\")\n\nfor (fruit in list_of_fruits) {\n  print(fruit)\n}\nThis loop’s job is to print out the variable fruit. But where is fruit defined? Well, the for loop runs print(fruit) for every element of list_of_fruits, storing the current element in the variable fruit. If we were to write it out explicitly, it would look like\nfruit &lt;- list_of_fruits[0]\nprint(fruit)\n\nfruit &lt;- list_of_fruits[1]\nprint(fruit)\n\nfruit &lt;- list_of_fruits[2]\nprint(fruit)\nLet’s return to our goal: working out which ones have an “a”. We need to put a conditional inside the loop:\nlist_of_fruits &lt;- c(\"apple\", \"banana\", \"cherry\")\n\nfor (fruit in list_of_fruits) {\n    if grepl(\"a\", fruit) { \n      print(paste(\"a is in\", fruit))\n    }\n    else {\n      print(paste(\"a is not in\", fruit))\n    }\n}\nFinally, it’s often convenient to loop through a list of numbers. R makes this easy with the x:y notation:\n1:10\ncontains all the integers between \\(1\\) and \\(10\\). To loop through each,\nfor (i in 1:10) {\n  print(i)\n}\nThe advantage of this approach is that we can loop through many numbers:\nfor (i in 1:1000) {\n  print(i)\n}\nThis can be useful if you need to loop through multiple objects by indexing.\n\n\nMapping with purrr\nConsider the follow situation. You have a dataset, and want to apply a function to every column. Or maybe some columns. What to do?\nYou could loop over them with a for loop. Alternatively, you could use the mapping functions in purrr, which simplifies the code.\nWhat is a map? Generally, a map takes something and makes it something else. So far, that’s the same a function. The difference is that a map takes lots of things and translates them all in the same way. For example, a geographical map takes life-sized locations and transforms them all in the same way to a hand-sized piece of paper.\nEssentially, maps are a way of transforming a selection of variables in the same way. We’ll start by brining in the purrr library\nlibrary(purrr)\nLet’s use the same data as in the statistics session:\nlibrary(dplyr)\nplayers &lt;- read.csv(\"data_sources/Players2024.csv\")\nplayers &lt;- players %&gt;% filter(positions != \"Missing\", height_cm &gt; 100)\nWhat if you want the median value from all columns? We can use the map_dbl() function to map doubles (long decimal numbers):\nmap_dbl(players, median)\nDon’t worry about the warnings - they’re just there because you can’t take the median of a non-numeric variable. To check which ones are, we can map the logical operator is.numeric:\nmap_lgl(players, is.numeric)\nWe can use the pipe here,\nplayers %&gt;% map_lgl(is.numeric)\nLet’s select the numeric columns and look at the medians again\nplayers %&gt;% \n  select_if(is.numeric) %&gt;%\n  map_dbl(median)\nWe can also create custom functions. We use .x to refer to the variable:\nplayers %&gt;% \n  select_if(is.numeric) %&gt;%\n  map_dbl(~max(.x) - min(.x))",
    "crumbs": [
      "Workshops",
      "Programming Essentials"
    ]
  },
  {
    "objectID": "Workshops/6 - Programming.html#building-your-own-machines",
    "href": "Workshops/6 - Programming.html#building-your-own-machines",
    "title": "Programming Essentials",
    "section": "Building your own machines",
    "text": "Building your own machines\nWe’ll wrap this session up by looking at custom functions. So far, we’ve only used built-in functions or those from other people’s modules. But we can make our own!\nWe’ve only ever called functions - this is what we do when we use them. All functions need a definition, this is the code that gets run when they’re called.\n\nThe function definition\nFunctions are machines. They take some inputs, run some code with those inputs, and spit out one output. We need to define how they work before we use them. We should specify\n\nA name\nSome inputs\nThe code to run (the machine itself)\n\nWe include these in three steps\n\nThe first line of the function definition (the function signature) specifies the name and inputs\nWe then indent all the code we want to run with our inputs\nWe end with a return statement, specifying the output\n\ninsert_function_name_here &lt;- function(input_1_name, input_2_name, ...) {\n  # Code code code\n}\nFor example, let’s create a function that converts centimetres to metres.\ncm_to_m &lt;- function(value_in_cm) {\n    value_in_cm / 100\n}\nTaking it apart, we have\n\nName: cm_to_m\nInputs (just one): value_in_cm\nCode (just one line): value_in_cm / 100\n\nImportantly, nothing appears when you run this code. Why? Because you’ve only defined the function, you haven’t used it yet.\nTo use this function, we need to call it. Let’s convert \\(10\\text{ cm}\\) to \\(\\text{m}\\).\ncm_to_m &lt;- function(value_in_cm) {\n    value_in_cm / 100\n}\n\ncm_to_m(10)\nWhen we call the function, it runs with value_in_cm &lt;- 10.\nThat’s it! Every function that you use, built-in or imported, looks like this.\nBecause functions must be defined before called, and defining them produces no output, best practice is to place functions at the top of your script, below the import statements.\n\nReturn values and default values\nOne quirk of R functions is that, by default, they return the output of the line. Let’s add a new line that prints the message “\\(x\\text{ cm} = y\\text{ m}\\)”. We’ll need to also save our calculation in the process:\ncm_to_m &lt;- function(value_in_cm) {\n    value_in_m &lt;- value_in_cm / 100\n    print(paste(value_in_cm, \"cm =\", value_in_m, \"m\"))\n}\n\ncm_to_m(10)\nIt works, but we have a problem. The output of the function is the whole message, not the value. The easiest way to fix this is to call the output on the last line:\ncm_to_m &lt;- function(value_in_cm) {\n    value_in_m &lt;- value_in_cm / 100\n    print(paste(value_in_cm, \"cm =\", value_in_m, \"m\"))\n    value_in_m\n}\n\ncm_to_m(10)\nAlternatively, you can use the return() function to exit before the end and manually specify the output.",
    "crumbs": [
      "Workshops",
      "Programming Essentials"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html",
    "href": "Workshops/2 - Data processing.html",
    "title": "R dplyr: preparing data for analysis",
    "section": "",
    "text": "UQ Library 2024-11-27",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html#what-are-we-going-to-learn",
    "href": "Workshops/2 - Data processing.html#what-are-we-going-to-learn",
    "title": "R dplyr: preparing data for analysis",
    "section": "What are we going to learn?",
    "text": "What are we going to learn?\nIn this hands-on session, we will use the dplyr package to transform your data.\nSpecifically, you will learn how to explore, filter, reorganise and process a dataframe with the following verbs:\n\nselect(): pick variables\nfilter(): pick observations\narrange(): reorder observations\nmutate(): create new variables\nsummarise(): collapse to a single summary\ngroup_by(): change the scope of function",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html#keep-in-mind",
    "href": "Workshops/2 - Data processing.html#keep-in-mind",
    "title": "R dplyr: preparing data for analysis",
    "section": "Keep in mind",
    "text": "Keep in mind\n\nEverything we write today will be saved in your project. Please remember to save it somewhere you can access it later if you wish to revisit what we do today.\nR is case sensitive: it will tell the difference between uppercase and lowercase.\nRespect the naming rules for objects (no spaces, does not start with a number…)\n\n\nHelp\nFor any dataset or function doubts that you might have, don’t forget the three ways of getting help in RStudio:\n\nthe shortcut command: ?functionname\nthe help function: help(functionname)\nthe keyboard shortcut: press F1 after writing a function name",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html#setting-up",
    "href": "Workshops/2 - Data processing.html#setting-up",
    "title": "R dplyr: preparing data for analysis",
    "section": "Setting up",
    "text": "Setting up\n\nInstall the dplyr package\nIf you don’t have it already, you can install dplyr with the command: install.packages(\"dplyr\")\n\nAlternatively, you can install the whole “tidyverse”, a meta-package useful for data science: install.packages(\"tidyverse\")\n\n\n\nNew project\n[comment] wonder if we need this, or just build on what happened in the intro? - Click the “File” menu button (top left corner), then “New Project” - Click “New Directory” - Click “New Project” (“Empty project” if you have an older version of RStudio) - In “Directory name”, type the name of your project, e.g. “dplyr_intro” - Select the folder where to locate your project: for example, the Documents/RProjects folder, which you can create if it doesn’t exist yet. - Click the “Create Project” button\n\n\nCreate a script\nWe will use a script to write code more comfortably.\n\nMenu: Top left corner, click the green “plus” symbol, or press the shortcut (for Windows/Linux) Ctrl+Shift+N or (for Mac) Cmd+Shift+N. This will open an “Untitled1” file.\nGo to “File &gt; Save” or press (for Windows/Linux) Ctrl+S or (for Mac) Cmd+S. This will ask where you want to save your file and the name of the new file.\nCall your file “process.R”\n\n\n\nIntroducing our data\nLet’s import and explore our data.\n\ncreate a data object called “gapminder”, using read.csv():\n\ngapminder &lt;- read.csv(\"https://raw.githubusercontent.com/resbaz/r-novice-gapminder-files/master/data/gapminder-FiveYearData.csv\")\n\nRemember you can use Ctrl+shift to execute a command from the script.\n\n\nYou can explore the gapminder dataset using dim(), head() and str()\n\nHow can we get the dataframe’s variable names? There are two ways: names(gapminder) returns the names regardless of the object type, such as list, vector, data.frame etc., whereas colnames(gapminder) returns the variable names for matrix-like objects, such as matrices, dataframes…\nTo return one specific column in the dataframe, you can use the dollar syntax: gapminder$year. For example, try these:\nclass(gapminder$country) # what kind of data?\n[1] \"character\"\nrange(gapminder$year) # what is the time range?\n[1] 1952 2007",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html#basic-dplyr-verbs",
    "href": "Workshops/2 - Data processing.html#basic-dplyr-verbs",
    "title": "R dplyr: preparing data for analysis",
    "section": "Basic dplyr verbs",
    "text": "Basic dplyr verbs\nThe R package dplyr was developed by Hadley Wickham for data manipulation.\nThe book R for Data Science introduces the package as follows:\n\nYou are going to learn the five key dplyr functions that allow you to solve the vast majority of your data manipulation challenges:\n\nPick variables by their names with select()\nPick observations by their values with filter()\nReorder the rows with arrange()\nCreate new variables with functions of existing variables with mutate()\nCollapse many values down to a single summary with summarise()\n\nThese can all be used in conjunction with group_by() which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the main verbs for a language of data manipulation.\n\nTo use the verbs to their full extent, we will use pipes and logical operators, which we will introduce as we go.\nLet’s load the dplyr package to access its functions:\nlibrary(dplyr)\n\nYou only need to install a package once (with install.packages()), but you need to reload it every time you start a new R session (with library()).\n\n\n1. Pick variables with select()\nselect() allows us to pick variables (i.e. columns) from the dataset. For example, to only keep the data about year, country and GDP per capita:\ngap_small &lt;- select(gapminder, year, country, gdpPercap)\nThe first argument refers to the dataframe that is being transformed, and the following arguments are the columns you want to keep. Notice that it keeps the order you specified?\nYou can also rename columns in the same command:\ngap_small &lt;- select(gapminder, year, country, gdpPerPerson = gdpPercap)\nIf you have many variables but only want to remove a small number, it might be better to deselect instead of selecting. You can do that by using the - character in front of a variable name:\nnames(select(gapminder, -continent))\n[1] \"country\"   \"year\"      \"pop\"       \"lifeExp\"   \"gdpPercap\"\nThere are also a lot of helper functions to select columns according to a logic. For example, to only keep the columns that have “a” in their names:\nnames(select(gapminder, contains(\"a\")))\n[1] \"year\"      \"gdpPercap\"\n\n\n2. Pick observations with filter()\nThe filter() function allows use to pick observations depending on one or several conditions. But to be able to define these conditions, we need to learn about logical operators.\nLogical operators allow us to compare things. Here are some of the most important ones:\n\n==: equal\n!=: different or not equal\n&gt;: greater than\n&lt;: smaller than\n&gt;=: greater or equal\n&lt;=: smaller or equal\n\n\nRemember: = is used to pass on a value to an argument, whereas == is used to check for equality. Using = instead of == for a logical statment is one of the most common errors and R will give you a reminder in the console when this happens.\n\nFor example, to filter the observations for Australia, we can use the following condition:\naustralia &lt;- filter(gapminder, country == \"Australia\")\naustralia\n# A tibble: 12 × 6\n   country    year      pop continent lifeExp gdpPercap\n   &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1 Australia  1952  8691212 Oceania      69.1    10040.\n 2 Australia  1957  9712569 Oceania      70.3    10950.\n 3 Australia  1962 10794968 Oceania      70.9    12217.\n 4 Australia  1967 11872264 Oceania      71.1    14526.\n 5 Australia  1972 13177000 Oceania      71.9    16789.\n 6 Australia  1977 14074100 Oceania      73.5    18334.\n 7 Australia  1982 15184200 Oceania      74.7    19477.\n 8 Australia  1987 16257249 Oceania      76.3    21889.\n 9 Australia  1992 17481977 Oceania      77.6    23425.\n10 Australia  1997 18565243 Oceania      78.8    26998.\n11 Australia  2002 19546792 Oceania      80.4    30688.\n12 Australia  2007 20434176 Oceania      81.2    34435.\nThe function compares the value “Australia” to all the values in the country variable, and only keeps the rows that have TRUE as an answer.\nNow, let’s filter the rows that have a life expectancy lifeExp greater than 81 years:\nlife81 &lt;- filter(gapminder, lifeExp &gt; 81)\ndim(life81)\n[1] 7 6\n\n\n3. Reorder observations with arrange()\narrange() will reorder our rows according to a variable, by default in ascending order:\narrange(life81, lifeExp)\n# A tibble: 7 × 6\n  country          year       pop continent lifeExp gdpPercap\n  &lt;chr&gt;           &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1 Australia        2007  20434176 Oceania      81.2    34435.\n2 Hong Kong China  2002   6762476 Asia         81.5    30209.\n3 Switzerland      2007   7554661 Europe       81.7    37506.\n4 Iceland          2007    301931 Europe       81.8    36181.\n5 Japan            2002 127065841 Asia         82      28605.\n6 Hong Kong China  2007   6980412 Asia         82.2    39725.\n7 Japan            2007 127467972 Asia         82.6    31656.\nIf we want to have a look at the entries with highest life expectancy first, we can use the desc() function (for “descending”):\narrange(life81, desc(lifeExp))\n# A tibble: 7 × 6\n  country          year       pop continent lifeExp gdpPercap\n  &lt;chr&gt;           &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1 Japan            2007 127467972 Asia         82.6    31656.\n2 Hong Kong China  2007   6980412 Asia         82.2    39725.\n3 Japan            2002 127065841 Asia         82      28605.\n4 Iceland          2007    301931 Europe       81.8    36181.\n5 Switzerland      2007   7554661 Europe       81.7    37506.\n6 Hong Kong China  2002   6762476 Asia         81.5    30209.\n7 Australia        2007  20434176 Oceania      81.2    34435.\n\nThe pipe operator\nWhat if we wanted to get that result in one single command, without an intermediate life81 object?\nWe could nest the commands into each other, the first step as the first argument of the second step:\narrange(filter(gapminder, lifeExp &gt; 81), desc(lifeExp))\n… but this becomes very hard to read, very quickly. (Imagine with 3 steps or more!)\nWe can make our code more readable and avoid creating useless intermediate objects by piping commands into each other. The pipe operator %&gt;% strings commands together, using the left side’s output as the first argument of the right side function.\nFor example, this command:\ngapminder %&gt;%\n  filter(lifeExp &gt; 81) %&gt;% \n  arrange(desc(lifeExp))\n\n… is equivalent to:\n\n``` r\narrange(filter(gapminder, lifeExp &gt; 81), desc(lifeExp))\nThe pipe operator can be read as “then” and makes the code a lot more readable than when nesting functions into each other, and avoids the creation of several intermediate objects. It is also easier to troubleshoot as it makes it easy to execute the pipeline step by step.\nFrom now on, we’ll use the pipe syntax as a default.\n\nNote that this material uses the magrittr pipe. The magrittr package is the one that introduced the pipe operator to the R world, and dplyr automatically imports this useful operator when it is loaded. However, the pipe being such a widespread and popular concept in programming and data science, it ended up making it into Base R (the “native” pipe) in 2021 with the release of R 4.1, using a different operator: |&gt;. You can switch your pipe shortcut to the native pipe in Tools &gt; Global options &gt; Code &gt; Use native pipe operator.\n\n\n\n\n4. Create new variables with mutate()\nHave a look at what the verb mutate() can do with ?mutate.\nLet’s see what the two following variables can be used for:\ngapminder %&gt;%\n    select(gdpPercap, pop)\n# A tibble: 1,704 × 2\n   gdpPercap      pop\n       &lt;dbl&gt;    &lt;dbl&gt;\n 1      779.  8425333\n 2      821.  9240934\n 3      853. 10267083\n 4      836. 11537966\n 5      740. 13079460\n 6      786. 14880372\n 7      978. 12881816\n 8      852. 13867957\n 9      649. 16317921\n10      635. 22227415\n# ℹ 1,694 more rows\nHow do you think we could combine them to add something new to our dataset?\nWe can use mutate() to create a gdp variable that tells us the total gdp.\nName your new dataset gap_gdp. When finished, dim(gap_gdp) should result in 1704 7.\nHint: use the * operator within mutate() to multiply the pop by gdpPercap.\ngap_gdp &lt;- gapminder %&gt;%\n    mutate(gdp = gdpPercap * pop)\ndim(gap_gdp)\n[1] 1704    7\nhead(gap_gdp)\n# A tibble: 6 × 7\n  country      year      pop continent lifeExp gdpPercap          gdp\n  &lt;chr&gt;       &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 Afghanistan  1952  8425333 Asia         28.8      779.  6567086330.\n2 Afghanistan  1957  9240934 Asia         30.3      821.  7585448670.\n3 Afghanistan  1962 10267083 Asia         32.0      853.  8758855797.\n4 Afghanistan  1967 11537966 Asia         34.0      836.  9648014150.\n5 Afghanistan  1972 13079460 Asia         36.1      740.  9678553274.\n6 Afghanistan  1977 14880372 Asia         38.4      786. 11697659231.\nYou can reuse a variable computed by ‘mutate()’ straight away. For example, we also want a more readable version of our new variable, in billion dollars:\ngap_gdp &lt;- gapminder %&gt;%\n    mutate(gdp = gdpPercap * pop,\n           gdpBil = gdp / 1e9)\n\n\n5. Collapse to a single value with summarise()\nsummarise() collapses many values down to a single summary. For example, to find the mean life expectancy for the whole dataset:\ngapminder %&gt;%\n  summarise(meanLE = mean(lifeExp))\n# A tibble: 1 × 1\n  meanLE\n   &lt;dbl&gt;\n1   59.5\nHowever, a single-value summary is not particularly interesting. summarise() becomes more powerful when used with group_by().\n\n\n6. Change the scope with group_by()\ngroup_by() changes the scope of the following function(s) from operating on the entire dataset to operating on it group-by-group.\nSee the effect of the grouping step:\ngapminder %&gt;%\n    group_by(continent)\n# A tibble: 1,704 × 6\n   country      year      pop continent lifeExp gdpPercap\n   &lt;chr&gt;       &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952  8425333 Asia         28.8      779.\n 2 Afghanistan  1957  9240934 Asia         30.3      821.\n 3 Afghanistan  1962 10267083 Asia         32.0      853.\n 4 Afghanistan  1967 11537966 Asia         34.0      836.\n 5 Afghanistan  1972 13079460 Asia         36.1      740.\n 6 Afghanistan  1977 14880372 Asia         38.4      786.\n 7 Afghanistan  1982 12881816 Asia         39.9      978.\n 8 Afghanistan  1987 13867957 Asia         40.8      852.\n 9 Afghanistan  1992 16317921 Asia         41.7      649.\n10 Afghanistan  1997 22227415 Asia         41.8      635.\n# ℹ 1,694 more rows\nThe data in the cells is the same, the size of the object is the same. However, the dataframe was converted to a tibble, because a dataframe is not capable of storing grouping information.\nUsing the group_by() function before summarising makes things more interesting. Let’s re-run the previous command, with the intermediate grouping step:\ngapminder %&gt;%\n  group_by(continent) %&gt;% \n  summarise(meanLE = mean(lifeExp))\n# A tibble: 5 × 2\n  continent meanLE\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Africa      48.9\n2 Americas    64.7\n3 Asia        60.1\n4 Europe      71.9\n5 Oceania     74.3\nWe now have the summary computed for each continent.\nSimilarly, to find out the total population per continent in 2007, we can do the following:\ngapminder %&gt;% \n    filter(year == 2007) %&gt;%\n    group_by(continent) %&gt;%\n    summarise(pop = sum(pop))\n# A tibble: 5 × 2\n  continent        pop\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Africa     929539692\n2 Americas   898871184\n3 Asia      3811953827\n4 Europe     586098529\n5 Oceania     24549947",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html#more-examples",
    "href": "Workshops/2 - Data processing.html#more-examples",
    "title": "R dplyr: preparing data for analysis",
    "section": "More examples",
    "text": "More examples\nAnother example of a summary, with a the starwars data set that dplyr provides:\nGrouping by species, summarise the number of characters per species and find the mean mass. Only for species groups with more than 1 character.\nstarwars %&gt;%\n  group_by(species) %&gt;%\n  summarise(\n    n = n(), # this counts the number of rows in each group\n    mass = mean(mass, na.rm = TRUE)\n  ) %&gt;%\n  filter(n &gt; 1) # the mean of a single value is not worth reporting\n# A tibble: 9 × 3\n  species      n  mass\n  &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n1 Droid        6  69.8\n2 Gungan       3  74  \n3 Human       35  81.3\n4 Kaminoan     2  88  \n5 Mirialan     2  53.1\n6 Twi'lek      2  55  \n7 Wookiee      2 124  \n8 Zabrak       2  80  \n9 &lt;NA&gt;         4  81  \nAn example of data manipulation and data visualisation in the same command with gapminder:\nSummarise the gapminder population data into total population per continent per year and plot coloured by continent.\n# increase in population per continent\nlibrary(ggplot2)\ngapminder %&gt;% \n  group_by(continent, year) %&gt;% \n  summarise(pop = sum(pop)) %&gt;% \n  ggplot(aes(x = year,\n             y = pop,\n             colour = continent)) +\n  geom_line()\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\nAnd another example, using using our gapminder dataset:\nLet’s say we want to calulate the variation (range) in life expectancy per country and plot the top and bottom 10 countries?\ngapminder %&gt;% \n  group_by(country) %&gt;% \n  summarise(maxLifeExp = max(lifeExp),\n            minLifeExp = min(lifeExp)) %&gt;% \n  mutate(dif = maxLifeExp - minLifeExp) %&gt;%  # new col with difference betwen max/min lifeExp\n  arrange(desc(dif)) %&gt;%  # arrange by dif, descending order for the next step\n  slice(1:10, (nrow(.)-10):nrow(.)) %&gt;%  # slice top 10 rows and bottom 10 rows\n  ggplot(aes(x = reorder(country, dif), y = dif)) +\n  geom_col() +\n  coord_flip() + # flip the x and y axis for a horizontal bar chart\n  labs(x = \"Country\",\n       y = \"Difference in Life Expectancy\") + # prettier labels for axes (which have been flipped) \n  annotate(\"segment\", x = 11.5, xend = 21.5, y = 39, yend = 39, colour = \"purple\", size=1, alpha=0.6) +\n  annotate(\"segment\", x = 0.5, xend = 11, y = 39, yend = 39, colour = \"green\", size=1, alpha=0.6) +\n    annotate(\"text\", x = c(5, 16), y = c(40, 40), \n           label = c(\"Smallest 10\", \"Largest 10\") ,\n           color=\"black\", size= 5 , angle=90) # add labels to colored lines\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "Workshops/2 - Data processing.html#close-project",
    "href": "Workshops/2 - Data processing.html#close-project",
    "title": "R dplyr: preparing data for analysis",
    "section": "Close project",
    "text": "Close project\nIf you want to close RStudio, make sure you save your script first.\nYou can then close the window, and if your script contains all the steps necessary for your data processing, it is safer to not save your workspace at the prompt. It should only take a second te execute all the commands stored in your script when you re-open your project.",
    "crumbs": [
      "Workshops",
      "R dplyr: preparing data for analysis"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Intro and Setting Up",
    "section": "",
    "text": "The R programming language is a language used for calculations, statistics, visualisations and many more data science tasks.\nRStudio is an open source Integrated Development Environment (IDE) for R, which means it provides many features on top of R to make it easier to write and run code.\nR’s main strong points are:\n\nOpen Source: you can install it anywhere and adapt it to your needs;\nReproducibility: makes an analysis repeatable by detailing the process in a script;\nCustomisable: being a programming language, you can create your own custom tools;\nLarge datasets: it can handle very large datasets (certainly well beyond the row limitations of Excel, and even further using HPCs and other tricks);\nDiverse ecosystem: packages allow you to extend R for thousands of different analyses.\n\nThe learning curve will be steeper than point-and-click tools, but as far as programming languages go, R is more user-friendly than others.\n\n\nFor this course, you need to have both R and RStudio installed (installation instructions).",
    "crumbs": [
      "Workshops",
      "Intro and Setting Up"
    ]
  },
  {
    "objectID": "setup.html#r-rstudio",
    "href": "setup.html#r-rstudio",
    "title": "Intro and Setting Up",
    "section": "",
    "text": "The R programming language is a language used for calculations, statistics, visualisations and many more data science tasks.\nRStudio is an open source Integrated Development Environment (IDE) for R, which means it provides many features on top of R to make it easier to write and run code.\nR’s main strong points are:\n\nOpen Source: you can install it anywhere and adapt it to your needs;\nReproducibility: makes an analysis repeatable by detailing the process in a script;\nCustomisable: being a programming language, you can create your own custom tools;\nLarge datasets: it can handle very large datasets (certainly well beyond the row limitations of Excel, and even further using HPCs and other tricks);\nDiverse ecosystem: packages allow you to extend R for thousands of different analyses.\n\nThe learning curve will be steeper than point-and-click tools, but as far as programming languages go, R is more user-friendly than others.\n\n\nFor this course, you need to have both R and RStudio installed (installation instructions).",
    "crumbs": [
      "Workshops",
      "Intro and Setting Up"
    ]
  },
  {
    "objectID": "setup.html#r-projects",
    "href": "setup.html#r-projects",
    "title": "Intro and Setting Up",
    "section": "R Projects",
    "text": "R Projects\nLet’s first create a new project:\n\nClick the “File” menu button (top left corner), then “New Project”\nClick “New Directory”\nClick “New Project”\nIn “Directory name”, type the name of your project, for example “YYYY-MM-DD_rstudio-intro”\nBrowse and select a folder where to locate your project (~ is your home directory). For example, a folder called “r-projects”.\nClick the “Create Project” button\n\n\nR Projects make your work with R more straight forward, as they allow you to segregate your different projects in separate folders. You can create a .Rproj file in a new directory or an existing directory that already has R code and data. Everything then happens by default in this directory. The .Rproj file stores information about your project options, and allows you to go straight back to your work.",
    "crumbs": [
      "Workshops",
      "Intro and Setting Up"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html",
    "href": "Workshops/1 - Fundamentals.html",
    "title": "The Fundamentals",
    "section": "",
    "text": "In this workshop, we will learn about:",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#maths-and-objects",
    "href": "Workshops/1 - Fundamentals.html#maths-and-objects",
    "title": "The Fundamentals",
    "section": "Maths and objects",
    "text": "Maths and objects\nThe console (by default at the bottom left in RStudio) is where most of the action happens. In the console, we can use R interactively. We write a command and then execute it by pressing Enter.\nIn its most basic use, R can be a calculator. Try executing the following commands:\n\n10 - 2\n\n[1] 8\n\n3 * 4\n\n[1] 12\n\n2 + 10 / 5\n\n[1] 4\n\n\nThose symbols are called “binary operators”: we can use them to multiply, divide, add and subtract. Once we execute the command (the “input”), we can see the result in the console (the “output”).\nWhat if we want to keep reusing the same value? We can store data by creating objects, and assigning values to them with the assignment operator &lt;-:\n\nnum1 &lt;- 42\nnum2 &lt;- num1 / 9\nnum2\n\n[1] 4.666667\n\n\n\nYou can use the shortcut Alt+- to type the assignement operator quicker.\n\nWe can also store text data:\n\nsentence &lt;- \"Hello World!\"\nsentence\n\n[1] \"Hello World!\"\n\n\nYou should now see your objects listed in you environment pane (top right).\nAs you can see, you can store different kinds of data as objects. If you want to store text data (a “string of characters”), you have to use quotes around them.\n\nYou can recall your recent commands with the up arrow, which is especially useful to correct typos or slightly modify a long command.\n\nUsing the console is great to test things and quickly run commands and get outputs. However, if we want to store our process and refine our code as we go over several sessions, it is best to work with a script. Let’s do a bit more setting up of our project.",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#create-a-folder-structure",
    "href": "Workshops/1 - Fundamentals.html#create-a-folder-structure",
    "title": "The Fundamentals",
    "section": "Create a folder structure",
    "text": "Create a folder structure\nTo keep it tidy, we are creating 3 folders in our project directory:\n\nscripts\ndata\nplots\n\nYou can do that with the “New Folder” button in the “Files” pane (bottom right of the window).",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#scripts",
    "href": "Workshops/1 - Fundamentals.html#scripts",
    "title": "The Fundamentals",
    "section": "Scripts",
    "text": "Scripts\nScripts are simple text files that contain R code. They are useful for:\n\nsaving a set of commands for later use (and executing it in one click)\nmaking research reproducible\nmaking writing and reading code more comfortable\ndocumenting the code with comments, and\nsharing your work with peers\n\nLet’s create a new R script with the menu: File &gt; New File &gt; R Script. (This can also be done with the first icon in the toolbar, or with the shortcut Ctrl+Shift+N.)\nThis opens our fourth pane in the top left of RStudio: the source pane.\n\nComments\nWe should start with a couple of comments, to document our script. Comments start with #, and will be ignored by R:\n# Description: Introduction to R and RStudio\n# Author: &lt;your name&gt;\n# Date: &lt;today's date&gt;\n\n\nSyntax highlighting\nNow, add some commands to your script:\n\nnum1 &lt;- 42\nnum2 &lt;- num1 / 9\n\nNotice the colours? This is called syntax highlighting. This is one of the many ways RStudio makes it more comfortable to work with R. The code is more readable when working in a script.\n\nWhile editing your script, you can run the current command (or the selected block of code) by using Ctrl+Enter. Remember to save your script regularly with the shortcut Ctrl+S. You can find more shortcuts with Alt+Shift+K, or the menu “Tools &gt; Keyboard Shortcuts Help”.",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#functions",
    "href": "Workshops/1 - Fundamentals.html#functions",
    "title": "The Fundamentals",
    "section": "Functions",
    "text": "Functions\nAn R function is a little program that does a particular job. It usually looks like this:\n&lt;functionname&gt;(&lt;argument(s)&gt;)\nArguments tell the function what to do. Some functions don’t need arguments, others need one or several, but they always need the parentheses after their name.\nFor example, try running the following command:\n\nround(num2)\n\n[1] 5\n\n\nThe round() function rounds a number to the closest integer. The only argument we give it is num2, the number we want to round.\n\nIf you scroll back to the top of your console, you will now be able to spot functions in the text.\n\n\nMany ways to do one thing\nAs in many programs, there are many ways to achieve one thing.\nFor example, we used the Graphical User Interface (GUI) to create directories and a script, but we could also:\n\nuse the shortcut Ctrl+Shift+N for a new script\nuse commands like dir.create(\"scripts\"), file.create(\"scripts/process.R\") and file.edit(\"scripts/process.R\")\n\nLearning about functions that do the same thing as the GUI will allow you to integrate them in scripts, and will sometimes help you to do things faster.\n\n\nHelp\nWhat if we want to learn more about a function?\nThere are two main ways to find help about a specific function in RStudio:\n\nthe shortcut command: ?functionname\nthe keyboard shortcut: press F1 with your cursor in a function name (you can do this by simply clicking on the function name)\n\nLet’s look through the documentation for the round() function:\n?round\nAs you can see, different functions might share the same documentation page.\nThere is quite a lot of information in a function’s documentation, but the most important bits are:\n\nDescription: general description of the function(s)\nUsage: overview of what syntax can be used\nArguments: description of what each argument is\nExamples: some examples that demonstrate what is possible\n\nSee how the round() function has a second argument available? Try this now:\n\nround(num2, digits = 2)\n\n[1] 4.67\n\n\nWe can change the default behaviour of the function by telling it how many digits we want after the decimal point, using the argument digits. And if we use the arguments in order, we don’t need to name them:\n\nround(num2, 2)\n\n[1] 4.67\n\n\nTo group values together in a single object, use the c() function.\nc() combines the arguments into a vector. In other words, it takes any number of arguments (hence the ...), and stores all those values together, as one single object. For example, let’s store the ages of our pet dogs in a new object:\n\nages &lt;- c(4, 10, 2, NA, 3)\n\n\nYou can store missing data as NA.\n\nWe can now reuse this vector, and calculate their human age:\n\nages * 7\n\n[1] 28 70 14 NA 21\n\n\nR can create visualisations with functions too. Try a bar plot of your dogs’ ages with the barplot() function:\n\nbarplot(ages)\n\n\n\n\n\n\n\n\nWe can customise the plot with a title and some colours, for example:\n\nbarplot(ages, main = \"How old are my dogs?\", col = \"pink\")\n\n\n\n\n\n\n\n\n\nChallenge 1 – Finding help\nUse the help pages to find out what these functions do, and try executing commands with them:\n\nrep.int()\nmean()\nrm()\n\nrep.int() creates vectors like c(), but it is designed to easily replicate values. For example, if you find something very funny:\n\nrep.int(\"Ha!\", 30)\n\n [1] \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\"\n[13] \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\"\n[25] \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\" \"Ha!\"\n\n\nThe next function, mean(), returns the mean of a vector of numbers:\n\nmean(ages)\n\n[1] NA\n\n\nWhat happened there?\nWe have an NA value in the vector, which means the function can’t tell what the mean is. If we want to change this default behaviour, we can use an extra argument: na.rm, which stands for “remove NAs”.\n\nmean(ages, na.rm = TRUE)\n\n[1] 4.75\n\n\n\nIn our last command, if we hadn’t named the na.rm argument, R would have understood TRUE to be the value for the trim argument!\n\nrm() removes an object from your environment (remove() and rm() point to the same function). For example:\n\nrm(num1)\n\n\nR does not check if you are sure you want to remove something! As a programming language, it does what you ask it to do, which means you might have to be more careful. But you’ll see later on that, when working with scripts, this is less of a problem.\n\nLet’s do some more complex operations by combining two functions:\nls() returns a character vector: it contains the names of all the objects in the current environment (i.e. the objects we created in this R session). Notice that this function doesn’t require us to provide any argument, but we still need to write the parentheses to run the function.\nIs there a way we could combine ls() with rm()?\nYou can remove all the objects in the environment by using ls() as the value for the list argument:\n\nrm(list = ls())\n\nWe are nesting a function inside another one. More precisely, we are using the output of the ls() function as the value passed on to the list argument in the rm() function.\n\n\n\nIncomplete functions\nIf you don’t finish a function, by leaving off the last bracket ) for example, the line of code won’t necessarily give you an error, but it won’t work very well. If you forget to include that last bracket, R will run the code, and then wait for further instructions before giving you an output. This will appear as a + in the console like so:\n&gt; round(1.23\n+\nIf you try to give any further instructions to R, it will likely just continue giving you + symbols, and not return anything. To stop this, click on the console and press the Esc key on your keyboard.\n\n\nMore help\nWe’ve practised how to find help about functions we know the name of. What if we don’t know what the function is called? Or if we want general help about R?\n\nThe function help.start() is a good starting point: it opens a browser of official R help.\nIf you want to search for a word in all the documentation, you can use the ?? syntax. For example, try executing ??anova.\nFinally, you will often go to your web browser and search for a particular question, or a specific error message: most times, there already is an answer somewhere on the Internet. The challenge is to ask the right question!",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#import-data",
    "href": "Workshops/1 - Fundamentals.html#import-data",
    "title": "The Fundamentals",
    "section": "Import data",
    "text": "Import data\n\nChallenge 2 – Import data\nCopy and paste the following two commands into your script:\ndownload.file(url = \"https://raw.githubusercontent.com/resbaz/r-novice-gapminder-files/master/data/gapminder-FiveYearData.csv\",\n  destfile = \"data/gapminderdata.csv\")\ngapminder &lt;- read.csv(\"data/gapminderdata.csv\")\nWhat do you think they do? Describe each one in detail, and try executing them.",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#explore-data",
    "href": "Workshops/1 - Fundamentals.html#explore-data",
    "title": "The Fundamentals",
    "section": "Explore data",
    "text": "Explore data\nWe have downloaded a CSV file from the Internet, and read it into an object called gapminder.\nYou can type the name of your new object to print it to screen:\n\ngapminder\n\nThat’s a lot of lines printed to your console. To have a look at the first few lines only, we can use the head() function:\n\nhead(gapminder)\n\n      country year      pop continent lifeExp gdpPercap\n1 Afghanistan 1952  8425333      Asia  28.801  779.4453\n2 Afghanistan 1957  9240934      Asia  30.332  820.8530\n3 Afghanistan 1962 10267083      Asia  31.997  853.1007\n4 Afghanistan 1967 11537966      Asia  34.020  836.1971\n5 Afghanistan 1972 13079460      Asia  36.088  739.9811\n6 Afghanistan 1977 14880372      Asia  38.438  786.1134\n\n\nNow let’s use a few functions to learn more about our dataset:\n\nclass(gapminder) # what kind of object is it stored as?\n\n[1] \"data.frame\"\n\nnrow(gapminder) # how many rows?\n\n[1] 1704\n\nncol(gapminder) # how many columns?\n\n[1] 6\n\ndim(gapminder) # rows and columns\n\n[1] 1704    6\n\nnames(gapminder) # variable names\n\n[1] \"country\"   \"year\"      \"pop\"       \"continent\" \"lifeExp\"   \"gdpPercap\"\n\n\nAll the information we just saw (and more) is available with one single function:\n\nstr(gapminder) # general structure\n\n'data.frame':   1704 obs. of  6 variables:\n $ country  : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...\n $ continent: chr  \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ lifeExp  : num  28.8 30.3 32 34 36.1 ...\n $ gdpPercap: num  779 821 853 836 740 ...\n\n\n\nThe RStudio’s environment panel already shows us some of that information (click on the blue arrow next to the object name).\n\nAnd to explore the data in a viewer, click on the table icon next to the object in the Environment pane.\nThis viewer allows you to explore your data by scrolling through, searching terms, filtering rows and sorting the data. Remember that it is only a viewer: it will never modify your original object.\n\nNotice that RStudio actually runs the View() function. Feel free to use that instead of clicking on the button, but note that the case matters: using a lowercase “v” will yield an error.\n\nTo see summary statistics for each of our variables, you can use the summary() function:\n\nsummary(gapminder)\n\n   country               year           pop             continent        \n Length:1704        Min.   :1952   Min.   :6.001e+04   Length:1704       \n Class :character   1st Qu.:1966   1st Qu.:2.794e+06   Class :character  \n Mode  :character   Median :1980   Median :7.024e+06   Mode  :character  \n                    Mean   :1980   Mean   :2.960e+07                     \n                    3rd Qu.:1993   3rd Qu.:1.959e+07                     \n                    Max.   :2007   Max.   :1.319e+09                     \n    lifeExp        gdpPercap       \n Min.   :23.60   Min.   :   241.2  \n 1st Qu.:48.20   1st Qu.:  1202.1  \n Median :60.71   Median :  3531.8  \n Mean   :59.47   Mean   :  7215.3  \n 3rd Qu.:70.85   3rd Qu.:  9325.5  \n Max.   :82.60   Max.   :113523.1  \n\n\nNotice how categorical and numerical variables are handled differently?\nLet’s now plot the relationship between GDP per capita and life expectancy:\n\nplot(gapminder$gdpPercap, gapminder$lifeExp,\n     xlab = \"GDP per capita (USD)\",\n     ylab = \"Life expectancy (years)\")\n\n\n\n\n\n\n\n\n\nFor more on visualisations, we will later dive into the popular ggplot2 package.\n\nFinally, let’s fit a linear model to see how strongly correlated the two variables are:\n\nlinear_model &lt;- lm(gapminder$lifeExp ~ gapminder$gdpPercap)\nsummary(linear_model)\n\n\nCall:\nlm(formula = gapminder$lifeExp ~ gapminder$gdpPercap)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-82.754  -7.758   2.176   8.225  18.426 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)         5.396e+01  3.150e-01  171.29   &lt;2e-16 ***\ngapminder$gdpPercap 7.649e-04  2.579e-05   29.66   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 10.49 on 1702 degrees of freedom\nMultiple R-squared:  0.3407,    Adjusted R-squared:  0.3403 \nF-statistic: 879.6 on 1 and 1702 DF,  p-value: &lt; 2.2e-16\n\n\nThe P-value suggests that there is a strong relationship between the two.",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#packages",
    "href": "Workshops/1 - Fundamentals.html#packages",
    "title": "The Fundamentals",
    "section": "Packages",
    "text": "Packages\nPackages add functionalities to R and RStudio. There are more than 21000 available.\nYou can see the list of installed packages in your “Packages” tab, or by using the library() function without any argument.\nWe are going to install a package called “skimr”. We can do that in the Packages tab:\n\nOpen the “Packages” tab (bottom-right pane)\nClick the “Install” button\nSearch for “skimr”\nClick “Install”\n\n\nNotice how it runs an install.packages() command in the console? You can use that too.\n\nIf I now try running the command skim(), I get an error. That’s because, even though the package is installed, I need to load it every time I start a new R session. The library() function does that. Let’s load the package, and use the skim() function to get an augmented summary of our gapminder dataset:\n\nlibrary(skimr) # load the package into your library\nskim(gapminder) # use a function from the package\n\n\nData summary\n\n\nName\ngapminder\n\n\nNumber of rows\n1704\n\n\nNumber of columns\n6\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n2\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncountry\n0\n1\n4\n24\n0\n142\n0\n\n\ncontinent\n0\n1\n4\n8\n0\n5\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nyear\n0\n1\n1979.50\n17.27\n1952.00\n1965.75\n1979.50\n1993.25\n2007.0\n▇▅▅▅▇\n\n\npop\n0\n1\n29601212.33\n106157896.75\n60011.00\n2793664.00\n7023595.50\n19585221.75\n1318683096.0\n▇▁▁▁▁\n\n\nlifeExp\n0\n1\n59.47\n12.92\n23.60\n48.20\n60.71\n70.85\n82.6\n▁▆▇▇▇\n\n\ngdpPercap\n0\n1\n7215.33\n9857.45\n241.17\n1202.06\n3531.85\n9325.46\n113523.1\n▇▁▁▁▁\n\n\n\n\n\nThis function provides further summary statistics, and even displays a small histogram for each numeric variable.\n\nPackages are essential to use R to its full potential, by making the most out of what other users have created and shared with the community. To get an idea of some of the most important packages depending on your field of study, you can start with the CRAN Task Tiews.\n\n\nChallenge 3\nFor a bit of fun:\n\nTry installing the package “cowsay” and using its function say().\nHave a look at the documentation and the package’s website.\nCan you make Clippy say the current time?\nCan you make a chicken say “bok” a thousand times? (Hint: look at the paste() function and its arguments.)",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#closing-rstudio",
    "href": "Workshops/1 - Fundamentals.html#closing-rstudio",
    "title": "The Fundamentals",
    "section": "Closing RStudio",
    "text": "Closing RStudio\nYou can close RStudio after making sure that you saved your script.\nWhen you create a project in RStudio, you create an .Rproj file that gathers information about the state of your project. When you close RStudio, you have the option to save your workspace (i.e. the objects in your environment) as an .Rdata file. The .Rdata file is used to reload your workspace when you open your project again. Projects also bring back whatever source file (e.g. script) you had open, and your command history. You will find your command history in the “History” tab (upper right panel): all the commands that we used should be in there.\nIf you have a script that contains all your work, it is a good idea not to save your workspace: it makes it less likely to run into errors because of accumulating objects. The script will allow you to get back to where you left it, by executing all the clearly laid-out steps.\nThe console, on the other hand, only shows a brand new R session when you reopen RStudio. Sessions are not persistent, and a clean one is started when you open your project again, which is why you have to load any extra package your work requires again with the library() function.",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/1 - Fundamentals.html#resources",
    "href": "Workshops/1 - Fundamentals.html#resources",
    "title": "The Fundamentals",
    "section": "Resources",
    "text": "Resources\n\nWe have a compilation of resources for the rest of your R learning\nAnd a cheatsheet of main terms and concepts for R",
    "crumbs": [
      "Workshops",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "Workshops/5 - Statistics.html",
    "href": "Workshops/5 - Statistics.html",
    "title": "Statistics",
    "section": "",
    "text": "This session is aimed as an overview of how to perform some statistical modelling with R. It is an R workshop, not a statistics workshop - if you’d like to better understand the statistical models, or need help deciding what’s best for you, please consult a statistics resource or contact a statistician.\nIn this session, we’ll cover\nWe’ll be working from our “Players2024” dataset. To bring it in and clean it up,",
    "crumbs": [
      "Workshops",
      "Statistics"
    ]
  },
  {
    "objectID": "Workshops/5 - Statistics.html#descriptive-statistics",
    "href": "Workshops/5 - Statistics.html#descriptive-statistics",
    "title": "Statistics",
    "section": "Descriptive Statistics",
    "text": "Descriptive Statistics\nWe’ll start with sample size. To calculate the number of non-empty observations in a column, say the numeric variable players$height_cm, we use the length() function\nlength(players$height_cm)\nWe can compute measures of central tendancy similarly. The average value is given by\nmean(players$height_cm)\nand the median by\nmedian(players$height_cm)\n\nMeasures of variance\nWe can also compute measures of variance. The minimum and maximum are as expected\nmin(players$height_cm)\nmax(players$height_cm)\nThe function range() yields both\nrange(players$height_cm)\nSo the actual range, i.e. the difference, is\ndiff(range(players$height_cm))\nQuartiles are given by quantile() and the inter-quartile range (IQR) by IQR():\nquantile(players$height_cm)\nIQR(players$height_cm)\nA column’s standard deviation and variance are given by\nsd(players$height_cm)\nvar(players$height_cm)\nAll together, you can see a nice statistical summary with\nsummary(players$height_cm)\n\n\nMeasures of correlation\nIf you’ve got two numeric variables, you might want to examine covariance and correlation. These indicate how strongly the variables are linearly related. We’ll need to use the players$age variable as well.\nThe covariance between “height_cm” and “age” is\ncov(players$height_cm, players$age)\nSimilarly, we can find the Pearson correlation coefficient between two columns.\ncor(players$height_cm, players$age)\nYou can also specify “kendall” or “spearman” for their respective correlation coefficients\ncor(players$height_cm, players$age, method = \"kendall\")\ncor(players$height_cm, players$age, method = \"spearman\")\n\n\nReminder about groupbys\nBefore we move to inferential statistics, it’s worth reiterating the power of groupbys discussed in the second workshop.\nTo group by a specific variable, like “positions”, we use\nplayers %&gt;% \n    group_by(positions)\nBy applying our statistics to the group_by object, we’ll apply them to every variable for each position.\nplayers %&gt;% \n    group_by(positions) %&gt;% \n    summarise(mean_height = mean(height_cm))",
    "crumbs": [
      "Workshops",
      "Statistics"
    ]
  },
  {
    "objectID": "Workshops/5 - Statistics.html#inferential-statistics",
    "href": "Workshops/5 - Statistics.html#inferential-statistics",
    "title": "Statistics",
    "section": "Inferential Statistics",
    "text": "Inferential Statistics\nWhile descriptive statistics describes the data definitively, inferential statistics aim to produce models for extrapolating conlusions.\n\nSimple linear regressions\nLeast-squares regression for two sets of measurements can be performed with the function lm. Recall that linear regressions have the mathematical form\n\\[ Y = β_1 X + β_0 \\]\nand we use the regression tool to estimate the parameters \\(β_0\\,,β_1\\). We can equivalently say that \\(Y \\sim X\\), which is what R takes in\nlm(\"height_cm ~ age\", players)\nIf we store this as a variable, we can then produce a summary of the results\nmodel &lt;- lm(\"height_cm ~ age\", players)\nsummary(model)\nIf you want to get specific parameters out, we can index with $:\nsummary(model)$r.squared\nThat’s a pretty shocking fit.\n\nPlotting it\nNaturally, you’d want to plot this. We’ll need to use techniques from the visualisation session. Let’s import ggplot2\nlibrary(ggplot2)\nStart by making a scatterplot of the data,\nggplot(players, aes(x = height_cm, y = age)) \n    + geom_point()\nThen, you’ll need to plot the regression as a line. For reference,\n\\[ y = \\text{slope}\\times x + \\text{intercept}\\]\nSo\nb0 &lt;- model$coefficients[1]\nb1 &lt;- model$coefficients[2]\n\nggplot(players, aes(x = age, y = height_cm)) + \n    geom_point() + \n    geom_abline(intercept = b0, slope = b1)\n\n\n\n\\(t\\)-tests\nWe can also perform \\(t\\)-tests. Typically, these are performed to examine the statistical signficance of a difference between two samples’ means. Let’s examine whether that earlier groupby result for is accurate for heights, specifically, are goalkeepers taller than non-goalkeepers?\nLet’s start by creating a new column with the values\n\n\n\nFALSE\nNon-goalkeeper\n\n\nTRUE\nGoalkeeper\n\n\n\nplayers &lt;- players %&gt;% \n  mutate(gk = positions == \"Goalkeeper\")\nThe \\(t\\)-test’s goal is to check whether \\(\\text{height_cm}\\) depends on \\(\\text{gk}\\), so the formula is \\(\\text{height\\_cm}\\sim\\text{gk}\\). This is given to the t.test function:\nt.test(height_cm ~ gk, data = players)\nYielding a p-value of \\(p&lt;2.2\\times10^{-16}\\), indicating that the null-hypothesis (heights are the same) is extremely unlikely.\nTo visualise this result, it might be helpful to produce a histogram of the heights\nggplot(players, \n       aes(x = height_cm, fill = gk)) + \n  geom_histogram(bins = 24)\n\n\nANOVAs\nWhat about the means of the other three? We could use an ANOVA to examine them. We use the aov() function for this.\nLet’s start by making a new dataset without goalkeepers\nno_gk &lt;- players %&gt;% filter(gk == FALSE)\nNext, we save the analysis of variance results\nres_aov &lt;- aov(height_cm ~ positions, data = no_gk)\nAnd examine them with summary()\nsummary(res_aov)\nEven without goalkeepers included, it looks like their positions are not all independent of height.\n\n\n\\(\\chi^2\\) tests\n\\(χ^2\\) tests are useful for examining the relationship of categorical variables by comparing the frequencies of each. Often, you’d use this if you can make a contingency table.\nWe only have one useful categorical variable here, “positions” (the others have too many unique values), so we’ll need to create another. Let’s see if there’s a relationship between players’ positions and names with the letter “a”.\nMake a binary column for players with the letter “a” in their names. To do this, we need to apply a string method to all the columns in the dataframe as follows\nplayers &lt;- players %&gt;%\n  mutate(a_in_name = grepl(\"a\", name))\n\nThe grepl function perform pattern matching: it checks if the pattern \"a\" is inside the values in name.\n\nLet’s cross tabulate positions with this new column\ntable(players$positions, players$a_in_name)\nThe \\(χ^2\\) test’s job is to examine whether players’ positions depend on the presence of “a” in their name. To evaluate it we need to send the contingency table in:\nchisq.test(table(players$positions, players$a_in_name))\nAs expected, there is no signifcant relationship. A simple bar plot can help us here\nggplot(players,\n       aes(x = positions, fill = a_in_name)) + \n  geom_bar()\nIf we use the position = \"fill\" parameter to geom_bar, we’ll see each as a proportion\nggplot(players,\n       aes(x = positions, fill = a_in_name)) + \n  geom_bar(position = \"fill\")\nIt looks as though the proportions are much the same.\n\n\nGeneralised linear models\nWe’ll finish by looking at Generalised Linear Models. The distributions they include are\n\nBinomial\nPoisson\nGaussian (Normal)\nGamma\nInverse Gaussian\nA few quasi options\n\nWe’ll use the binomial option to create logistic regressions.\nLogistic regressions examine the distribution of binary data. For us, we can compare the heights of goalkeepers vs non-goalkeepers again.\nNow, we can model this column with height. We’ll do the same as our \\(t\\)-test case, but this time we need to specify that family = binomial to ensure we’ll get a logistic:\nres_logistic &lt;- glm(gk ~ height_cm, family = binomial, data = players)\nWe can take a look at the results with\nsummary(res_logistic)\nLet’s have a look at the summary:\nres.summary()\nAnd we can then visualise it with ggplot2. We need to make another variable, because we need to replace TRUE \\(\\rightarrow\\) 1 and FALSE \\(\\rightarrow\\) 0 for the plot.\nplayers &lt;- players %&gt;% mutate(gk_numeric = as.numeric(gk))\nNow we can plot the logistic regression. The fitted values (on the \\(y\\)-axis) are stored in res_logistic$fitted.values, but there are no provided \\(x\\)-values - these come from the players dataset. Use geom_point() for the data and geom_line() for the fit:\nggplot(players, aes(x = height_cm, y = gk_numeric)) + \n  geom_point() + \n  geom_line(aes(y = res_logistic$fitted.values))",
    "crumbs": [
      "Workshops",
      "Statistics"
    ]
  },
  {
    "objectID": "Workshops/index.html",
    "href": "Workshops/index.html",
    "title": "Workshops",
    "section": "",
    "text": "Over these three days we’ll cover six sessions of content:\n\n\n\nSession\nDescription\n\n\n\n\nThe Fundamentals\nThe basics of Python. Variables, functions and modules.\n\n\nData processing\nImporting, manipulating and analysing data with pandas\n\n\nVisualisation\nCreating visualisations of our data with seaborn, matplotlib and plotly\n\n\nSharing and Publishing\nUsing GitHub for sharing and version control, as well as quarto for publishing dashboards and websites.\n\n\nStatistics\nDescriptive and inferential statistics, with some regressions and hypothesis testing, using scipy.stats and statsmodels\n\n\nProgramming Essentials\nPython tools everyone should know. Conditionals, loops, functions and importing scripts.\n\n\n\nThese content sessions are pretty packed, and we won’t have too much time to deviate. That’s why we’ll also have five project sessions - see The Project for details. You’re welcome to ask lengthier questions and play around there!",
    "crumbs": [
      "Workshops"
    ]
  }
]